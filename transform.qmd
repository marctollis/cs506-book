---
title: "Transform: Logical Vectors and Numbers"
---

What are the types of variables we see in data frames, and what are the different tools we can use to work with them?

## Learning Objectives

By the end of this chapter, you should be able to:

-   Understand how logical vectors work in R
-   Use logical conditions to filter and manipulate data

------------------------------------------------------------------------

## Logical Vectors

Logical vectors contain only `TRUE`, `FALSE`, or `NA`.

```{r}
x <- c(TRUE, FALSE, TRUE, NA)
x
```

### Logical comparisons create logical vectors:

```{r}
nums <- c(2, 5, 8, 1)
nums > 4
```

You can use these directly with functions like `sum()` and `mean()`:

```{r}
sum(nums > 4)   # Count how many values are > 4
mean(nums > 4)  # Proportion of values > 4
```

------------------------------------------------------------------------

### In-Class Exercise 1 – Logical Conditions

1.  Create a numeric vector with 10 random values.\
2.  How many values are greater than the mean?
3.  What proportion is above the mean?

```{r}
# use sample() to create a random list:
rands <- sample(x = c(1:10), size = 10)
sum(rands > mean(rands)) # number of values above the mean
mean(rands > mean(rands)) # proportion of values above the mean
```

------------------------------------------------------------------------

## Logical Operations

Combine logical vectors with `&` (and), `|` (or), and `!` (not):

```{r}
a <- c(TRUE, FALSE, TRUE)
b <- c(TRUE, TRUE, FALSE)

a & b # and
a | b # or
!a # not
```

------------------------------------------------------------------------

### In-Class Exercise 2 – Combining Conditions

1.  Using the `mpg` dataset, create a logical condition for cars with `hwy > 30` **and** `cyl == 4`.\
2.  How many such cars exist?

```{r}
library(tidyverse)

mpg |>
  filter(hwy > 30 & cyl == 4) |>
  nrow()
```

------------------------------------------------------------------------

## Comparisons

The following filter (using `filter`) finds all daytime departures that arrive roughly on time:

```{r}
library(nycflights13)
flights |> 
  filter(dep_time > 600 & dep_time < 2000 & abs(arr_delay) < 20)

```

The underlying logical variables can be made visible with `mutate()`:

```{r}
flights |> 
  mutate(
    daytime = dep_time > 600 & dep_time < 2000,
    approx_ontime = abs(arr_delay) < 20,
    .keep = "used"
  )
```

Which really means that the first filter is equivalent to:

```{r}
flights |> 
  mutate(
    daytime = dep_time > 600 & dep_time < 2000,
    approx_ontime = abs(arr_delay) < 20,
  ) |> 
  filter(daytime & approx_ontime)
```

------------------------------------------------------------------------

### Floating point comparison

What happens when you use `==` with numbers? Check it out:

What are the outcomes of these two equations?

```{r}
x <- c(1 / 49 * 49, sqrt(2) ^ 2)
x
```

Looks like 1 and 2.

Now look:

```{r}
x == c(1, 2)
```

You get all `FALSE`. This is because there’s no way to exactly represent 1/49 or `sqrt(2)` without **ROUNDING**:

```{r}
print(x, digits = 16)
```

So `==` is dangerous with numbers. But, you can use `dplyr::near`:

```{r}
near(x, c(1, 2))
```

### Missing values

Missing values pop up easily in `R` because unknown values are always evaluated that way. If:

```{r}
NA > 5
```

Then the following should be true:

```{r}
10 == NA
```

Same here:

```{r}
NA == NA
```

Print the flights where `dep_time` is missing. Well, you might want to do this:

```{r}
flights |>
  filter(dep_time == NA)
```

But it gives `NA` for every row, so you get nothing. This is where `is.na()` comes in handy:

```{r}
flights |> 
  filter(is.na(dep_time))
```

## Boolean algebra

You can combine logical vectors using Boolean algebra.

For instance, this will find all rows where `x` is not missing.

```{r eval=FALSE}
df |>
  filter(!is.na(x))
```

This will find all rows where `x` is smaller than -10 or bigger than 0.

```{r eval = FALSE}
df |>
  filter(x < -10 | x > 0)
```

### Missing values

```{r}
df <- tibble(x = c(TRUE, FALSE, NA))

df |>
  mutate(
    and = x & NA,
    or = x | NA
  )
```

This is based on "`TRUE` and `NA`" evaluates to `NA` while "`TRUE` or `NA`" evaluates to `TRUE` (because at least one of them is `TRUE`).

### Order of operations and `%in%`

Note the difference between these two outputs:

```{r}
flights |> 
   filter(month == 11 | month == 12)
```

```{r}
flights |> 
   filter(month == 11 | 12)
```

The second one doesn't work properly. It doesn't evaluate as "Find all flights that departed in November or December."

This is because `month == 11` creates a logical vector. This vector is then compared to `12`, which evaluates to `TRUE` - so it prints the whole table. Here is an illustration:

```{r}
flights |> 
  mutate(
    nov = month == 11,
    final = nov | 12,
    .keep = "used"
  )
```

This is where `%in%` comes in. `x %in% y` outputs a logical vector the same length as `x` that is `TRUE` whenever a value in `x` is in `y`.

```{r}
1:12 %in% c(1,5,11)
```

```{r}
letters[1:10] %in% c("a", "e", "i", "o", "u")
```

### In-Class Exercise

Find all the flights in November and December with `%in%`

```{r}
flights |>
  filter(month %in% c(11,12))
```

## In-Class Challenge

1.  Find all flights where `arr_delay` is missing but `dep_delay` is not.\
2.  Find all flights where neither `arr_time` nor `sched_arr_time` are missing, but `arr_delay` is.

## Summaries

### Logical summaries `any()` and `all()`

`any()` returns `TRUE` if there are any `TRUE`s in `x`. (same as `|`)

`all()` returns `TRUE` only if all values of `x` are `TRUE`'s. (same as `&`)

### In-Class Exercise

Use `all()` and `any()` to find out if every flight was delayed on departure by at most an hour or if any flights were delayed on arrival by five hours or more.

Using `group_by` allows us to do that by day:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    all_delayed = all(dep_delay <= 60, na.rm = TRUE),
    any_long_delay = any(arr_delay >= 300, na.rm = TRUE),
    .groups = "drop"
  )
```

### Numeric summaries of logical vectors

-   `sum(x)` gives the number of `TRUE`s.\
-   `mean(x)` gives the proportion of `TRUE`s.

### In-Class Exercise

What are the proportion of flights that were delayed on departure by **at most** an hour, and the number of flights that were delayed on arrival by five hours or more?

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    proportion_delayed = mean(dep_delay <= 60, na.rm = TRUE),
    count_long_delay = sum(arr_delay >= 300, na.rm = TRUE),
    .groups = "drop"
  )
```

### Logical subsetting

You can use a logical vector to filter a single variable to a subset of interest. We can subset using `[]`.

### In-Class Exercise

Compute the average delay for flights that arrived early.

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    behind = mean(arr_delay[arr_delay > 0], na.rm = TRUE),
    ahead = mean(arr_delay[arr_delay < 0], na.rm = TRUE),
    n = n(),
    .groups = "drop"
  )
```

## Conditional Transformations

A lot of the time, we want to do one thing for condition x, and something different for condition y.

You can use conditional transformations with logical vectors to do this.

### `if_else()`

There are four arguments to `if_else`:\
1. `condition`: a logical vector.\
2. `true`: gives the output when the condition is true.\
3. `false`: gives the output when the condition is false.\
4 (optional). `missing`: gives the output if the input is `NA`.\

```{r}
# assign a vector of integers between -3 and 3 to a variable, and tack an NA on the end of that vector:
x <- c(-3:3, NA)
```

Let's use `if_else` to label a vector as either positive ("+ve") or negative ("-ve"):

```{r}
if_else(x > 0, "+ve", "-ve", "???")
```

**\<**<wink wink>\>: notice something weird here? We'll come back to it.

To stick with our new tradition of using vectors in our arguments:

```{r}
# If x is negative, then print the negative of it, else print the positive
# this is kind of like abs().
if_else(x < 0, -x, x)
```

You can also mix and match different vectors:

```{r}
x1 <- c(NA, 1, 2, NA)
y1 <- c(3, NA, 4, 6)
if_else(is.na(x1), y1, x1)
```

### `case_when`

This is a flexible way of performing different computations for different conditions.

The syntax is not something we are very used to in the `tidyverse`. It contains pairs of `condition ~ output`, where `condition` is a logical vector. When `condition == TRUE`, the output is used.

The reason we use it is because `if_else` can get ugly quickly. For instance, if we want to resolve the fact that zero is neither positive or negative in our `x` vector above (see the **\<**<wink wink>\>), we have to do some fancy nesting:

```{r}
if_else(x == 0, "0", if_else(x < 0, "-ve", "+ve"), "???")
```

But `case_when` can reslove this quite easily:

```{r}
x <- c(-3:3, NA)
case_when(
  x == 0   ~ "0",
  x < 0    ~ "-ve", 
  x > 0    ~ "+ve",
  is.na(x) ~ "???"
)
```

### In-Class Challenge

Use `case_when` to add a `status` columns containing human-readable labels to the `flights` table that describe arrival delays from the `arr_delay` column.\
1. When `arr_delay` is missing, the flight is "cancelled".\
2. When `arr_delay` is 30 minutes early or more, it is "very early".\
3, When `arr_delay` is less than 15 minutes early or late, it is "on time".\
4. When `arr_delay` is less than 60 minutes late, it is "late".\
5. When`arr_delay`is more than an hour but less than`Inf\` (infinity) late, it is "very late"\

Hint: keep the "used" columns.

```{r}
flights |> 
  mutate(
    status = case_when(
      is.na(arr_delay)      ~ "cancelled",
      arr_delay < -30       ~ "very early",
      arr_delay < -15       ~ "early",
      abs(arr_delay) <= 15  ~ "on time",
      arr_delay < 60        ~ "late",
      arr_delay < Inf       ~ "very late",
    ),
    .keep = "used"
  )
```

# Next Steps

Next, you’ll learn how to manipulate and clean **strings** using the `stringr` package.
